// #include "common/engine_loader.hpp"
// #include <cuda_runtime_api.h>
// #include <memory>
// #include <opencv2/opencv.hpp>

// using namespace nvinfer1;

// int main() {
//     // 使用智能指针加载TensorRT引擎
//     auto engine = loadEngine("./models/yolov8n.engine");
//     if (!engine) {
//         std::cerr << "Failed to load engine." << std::endl;
//         return -1;
//     }

//     // 输出引擎的Input和Output信息
//     // printBindingsInfo(engine.get());

//     // 使用智能指针创建执行上下文
//     auto context = createExecutionContext(engine.get());

//     // 输入输出缓冲区大小
//     // int inputIndex = engine->getBindingIndex("images");  // Deprecated: 未来可能会有替代API
//     // int outputIndex = engine->getBindingIndex("output0");  // Deprecated: 未来可能会有替代API

//     // int inputIndex = engine->getTensorShape("images");
//     // int outputIndex =

//     // 输出dims的信息
//     // TODO

//     // void* buffers[2];
//     // cudaMalloc(&buffers[inputIndex], 1 * 3 * 640 * 640 * sizeof(float)); // 替换为实际输入大小
//     // cudaMalloc(&buffers[outputIndex], 1 * 84 * 8400 * sizeof(float)); // 替换为实际输出大小

//     // // 读取视频文件
//     // cv::VideoCapture cap("highway_tilt_01.mp4");
//     // if (!cap.isOpened()) {
//     //     std::cerr << "Failed to open video file." << std::endl;
//     //     return -1;
//     // }

//     // cv::Mat frame;
//     // while (cap.read(frame)) {
//     //     // 预处理图像（调整大小、归一化等）
//     //     cv::Mat resizedFrame;
//     //     cv::resize(frame, resizedFrame, cv::Size(640, 640));
//     //     resizedFrame.convertTo(resizedFrame, CV_32FC3, 1.0 / 255.0);

//     //     // 将OpenCV Mat转换为CUDA buffer
//     //     cudaMemcpy(buffers[inputIndex], resizedFrame.ptr<float>(), 1 * 3 * 640 * 640 * sizeof(float), cudaMemcpyHostToDevice);

//     //     // 执行推理
//     //     context->executeV2(buffers);

//     //     // 处理推理输出（根据具体模型的输出格式）
//     //     // 假设输出格式是 1 x 84 x 8400 的浮点数
//     //     std::vector<float> output(1 * 84 * 8400);
//     //     cudaMemcpy(output.data(), buffers[outputIndex], output.size() * sizeof(float), cudaMemcpyDeviceToHost);

//     //     // 在这里处理推理结果
//     //     // TODO 能否用一些矩阵工具来处理数据？

//     //     // 显示结果
//     //     cv::imshow("Result", frame);
//     //     if (cv::waitKey(30) >= 0) break;
//     // }

//     // // 释放资源
//     // cudaFree(buffers[inputIndex]);
//     // cudaFree(buffers[outputIndex]);

//     return 0;
// }